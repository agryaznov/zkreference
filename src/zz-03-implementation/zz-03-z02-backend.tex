%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Backends: Cryptographic System Implementations}
\label{implem:backends}

The backend of a ZK proof implementation is the portion of the software that contains an implementation of the low-level cryptographic protocol. It proves statements where the instance and witness are expressed as variable assignments, and relations are expressed via low-level languages (such as arithmetic circuits, Boolean circuits, R1CS/QAP constraint systems or arithmetic constraint satisfaction problems).

\futfig{add a figure with the different components of a backend in a ``table hierarchy''}

\xetexfontscale{.98}{The backend typically consists of a concrete implementation of a proposed ZK proof system(s) (often specified by pseudocode in a paper publication), along with supporting code for the required arithmetic operations, serialization formats, tests, benchmarking, etc.
There are numerous backends, most originated as academic research prototypes and available as open-source projects. 
The offerings and features of backends evolve rapidly, so it can be useful to consult a curated taxonomy \cite{url:ZKP-science}.}

Considerations for the choice of backends include:

\begin{itemize}
\item ZK proof system(s) implemented by the backend, and their associated security, assumptions and asymptotic performance (as discussed in the Security Track document)
\item Concrete performance (see Benchmarks section)
\item Programming language and API style (this consideration may be satisfied by adherence to prospective ZK proof standards; see the the API and File Formats section)
\item Platform support
\item Availability as open source
\item Active community of maintainers and users
\item Correctness and robustness of the implementation (as determined, e.g., by auditing and formal verification)
\item Applications (as evidence of usability and scrutiny).
\end{itemize}
