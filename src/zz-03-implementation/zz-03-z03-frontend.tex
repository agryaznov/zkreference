%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Frontends: Constraint-System Construction}
\label{implem:frontends}

The frontend of a ZK proof system implementation provides means to express statements in a convenient language and to prove such statements in zero knowledge by compiling them into a low-level representation and invoking a suitable ZK backend.

A frontend consists of:
\begin{itemize}
\item The specification of a high-level language for expressing statements.
\item A compiler that converts relations expressed in high-level language into low-level relations suitable for some backend(s). For example, this may produce an R1CS constraint system.
\item Instance reduction: conversion of the instance in a high-level statement to a low-level instance (e.g., assignment to R1CS instance variables).
\item Witness reduction: conversion of the witness to a high-level statement to a low-level witness (e.g., assignment to witness variables).
\item \xetexfontscale{.99}{Typically, a library of ``gadgets'' with useful and hand-optimized building blocks for statements.}
\end{itemize}		

\futfig{add figure that expresses example / abstract circuit that shows what inputs are private / public (witness vs instance) and the way that gadgets can be composed}

Languages for expressing statements, which have been implemented in frontends to date include: code library for general-purpose languages, domain-specific language, suitably-adapted general-purpose high-level language, and assembly language for a virtual CPU.

Frontends' compilers, as well as gadget libraries, often implement optimizations aiming at reducing the cost of the constraint systems (e.g., the number of constraints and variables).
This includes techniques such as making use of ``free linear combinations'' in R1CS, using nondeterministic advice given in witness variables (e.g., for integer arithmetic or random-access memory), removing redundancies, using cryptographic schemes tailored for the given algebraic settings (e.g., Pedersen hashing on the Jubjub curve or MiMC for hash functions, RSA verification for digital signatures), and many other techniques.
For example, see further discussion in the Zcon0 Circuit Optimisation handout \cite{2018:Dai:ZCon0:handout}.

There are many implemented frontends, including some that provide alternative ways to invoke the same underlying backends. Most have originated as academic research prototypes, and are available as open-source projects. 
The offerings and features of frontends evolve rapidly, so it can be useful to consult a curated taxonomy \cite{url:ZKP-science}.
